package day13

import (
	"fmt"

	"github.com/davecgh/go-spew/spew"
	"github.com/fatih/color"
)

var Ash = "."
var Fog = "#"

var blue = color.New(color.FgBlue).SprintFunc()
var cyan = color.New(color.FgCyan).SprintFunc()
var green = color.New(color.FgGreen).SprintFunc()
var red = color.New(color.FgRed).SprintFunc()

func findReflections(rows []string) map[int][]int {
	mirrors := make(map[int][]int)
	printString := ""

	for rowIndex, l := range rows {
		if _, ok := mirrors[rowIndex]; !ok {
			mirrors[rowIndex] = []int{0, 0}
		}

		if rowIndex > 0 && rowIndex < len(rows)-1 {
			if l == rows[rowIndex+1] {
				printString += fmt.Sprintf("%+s \n", green(string(l), " < Found Mirror"))
				mirrors[rowIndex] = []int{rowIndex, 0}
				var depth = 0

				for i := 0; i <= rowIndex; i++ {
					// fmt.Print("Doin stuff \n", rows[i], " ", rowIndex, i, rowIndex-i, rowIndex+i, "\n")
					// fmt.Printf("Comparing %+v with %+v \n", rows[rowIndex-i], rows[rowIndex+i+1])

					if len(rows) > rowIndex+i+1 && rowIndex-i > 0 {
						if rows[rowIndex-i] == rows[rowIndex+i+1] {
							depth++
							printString += fmt.Sprintf("%+s \n", cyan(string(rows[rowIndex+i]), " < Found Reflection"))
							mirrors[rowIndex][1] = depth
						}
					}
				}

			} else {
				printString += fmt.Sprintf("%+s \n", blue(string(l)))
			}
		} else {
			printString += fmt.Sprintf("%+s \n", blue(string(l)))
		}
	}

	fmt.Print(printString)
	spew.Dump(mirrors)

	return mirrors
}

func FindReflections(i []string) int {
	// patterns := make(map[int]Pattern)
	// currentPatternIndex := 0

	sum := 0

	horizontalMirrors := findReflections(i)

	// add new line at the end since its not been recognized properly
	// i = append(i, "")

	// for lI, l := range i {

	// 	if _, ok := patterns[currentPatternIndex]; !ok {
	// 		patterns[currentPatternIndex] = Pattern{
	// 			patternRange: []int{lI},
	// 			hRefMap:      make(map[int]int),
	// 			vRefMap:      make(map[int]int),
	// 		}
	// 	}

	// 	if l == "" {
	// 		pattern := patterns[currentPatternIndex]
	// 		pattern.patternRange = append(pattern.patternRange, lI)
	// 		patterns[currentPatternIndex] = pattern
	// 		rangeOfLines := i[pattern.patternRange[0]:pattern.patternRange[1]]

	// 		for lI2, l2 := range rangeOfLines {
	// 			if _, ok := patterns[currentPatternIndex].hRefMap[lI2]; !ok {
	// 				patterns[currentPatternIndex].hRefMap[lI2] = 0
	// 			}

	// 			if lI2 == 0 || lI2 == len(rangeOfLines) {
	// 				patterns[currentPatternIndex].hRefMap[lI2] = 0
	// 			} else {
	// 				for cI := range l2 {
	// 					if lI2 < len(rangeOfLines)-1 && lI2 > 1 {
	// 						topDistance := lI2
	// 						bottomDistance := len(rangeOfLines) - lI2
	// 						offset := topDistance

	// 						if topDistance > bottomDistance {
	// 							offset = bottomDistance
	// 						}

	// 						currentChunk := ""
	// 						nextChunk := ""

	// 						for _, l3 := range rangeOfLines[lI2-offset : lI2] {
	// 							currentChunk += string(l3[cI])
	// 						}

	// 						for _, l4 := range rangeOfLines[lI2 : lI2+offset] {
	// 							nextChunk += string(l4[cI])
	// 						}

	// 						if len(currentChunk) > 1 && len(nextChunk) > 0 {
	// 							var condition = strings.HasPrefix(nextChunk, Reverse(currentChunk))
	// 							matchingChunkLength := len(currentChunk)

	// 							if len(currentChunk) > len(nextChunk) {
	// 								condition = strings.HasPrefix(Reverse(currentChunk), nextChunk)
	// 								matchingChunkLength = len(nextChunk)
	// 							}

	// 							if condition {
	// 								if patterns[currentPatternIndex].hRefMap[lI2] >= 0 {
	// 									patterns[currentPatternIndex].hRefMap[lI2] = matchingChunkLength
	// 								}
	// 							} else {
	// 								patterns[currentPatternIndex].hRefMap[lI2] = -1
	// 							}
	// 						}
	// 					}
	// 				}
	// 			}
	// 		}

	// 		currentPatternIndex++
	// 		continue
	// 	}

	// 	for cI := range l {
	// 		if _, ok := patterns[currentPatternIndex].vRefMap[cI]; !ok {
	// 			patterns[currentPatternIndex].vRefMap[cI] = 0
	// 		}

	// 		if cI == 0 || cI == len(l) {
	// 			patterns[currentPatternIndex].hRefMap[cI] = 0
	// 		} else {
	// 			if cI < len(l)-1 && cI > 0 {
	// 				var current = l[:cI]
	// 				var end = l[cI : len(l)-1]
	// 				matchingChunkLength := len(current)

	// 				if len(current) > 1 && len(end) > 0 {
	// 					var condition = strings.HasPrefix(end, Reverse(current))

	// 					if len(current) > len(end) {
	// 						condition = strings.HasPrefix(Reverse(current), end)
	// 						matchingChunkLength = len(end)
	// 					}

	// 					if condition {
	// 						if patterns[currentPatternIndex].vRefMap[cI] >= 0 {
	// 							patterns[currentPatternIndex].vRefMap[cI] = matchingChunkLength
	// 						}
	// 					} else {
	// 						patterns[currentPatternIndex].vRefMap[cI] = -1
	// 					}
	// 				}
	// 			}
	// 		}
	// 	}
	// }

	// sum := 0

	// // spew.Dump(patterns)

	// for patternKey, pattern := range patterns {
	// 	sumPerPattern := 0

	// 	highestVertical := []int{0, 0}
	// 	highestHorizontal := []int{0, 0}
	// 	choseVertical := true

	// 	for vKey, vertical := range pattern.vRefMap {
	// 		if vertical == 0 {
	// 			continue
	// 		}

	// 		if vertical >= highestVertical[1] && vKey > highestVertical[0] {
	// 			highestVertical = []int{vKey, vertical}
	// 		}
	// 	}

	// 	for hKey, horizontal := range pattern.hRefMap {
	// 		if horizontal == 0 {
	// 			continue
	// 		}

	// 		if horizontal >= highestHorizontal[1] && hKey > highestHorizontal[0] {
	// 			highestHorizontal = []int{hKey, horizontal}
	// 		}
	// 	}

	// 	if highestVertical[1] > highestHorizontal[1] {

	// 		sumPerPattern += highestVertical[0]

	// 	} else {
	// 		sumPerPattern += 100 * highestHorizontal[0]
	// 		choseVertical = false
	// 	}

	// 	if len(i) >= pattern.patternRange[1] && pattern.patternRange[1] > 0 && len(pattern.hRefMap) > 0 {
	// 		fmt.Printf("\nPattern: %+v, IsVertical: %+v, Sum: %+v -----------------\n\n", patternKey, choseVertical, sumPerPattern)

	// 		printString := ""
	// 		columnHead := "    "
	// 		columnHeadAdded := false

	// 		for lineIndex, line := range i[pattern.patternRange[0]:pattern.patternRange[1]] {
	// 			if !choseVertical && highestHorizontal[0] == lineIndex {
	// 				printString += fmt.Sprintf("%+v %+v %+v \n", green(lineIndex), green(">"), green(line))
	// 			} else {
	// 				printString += "    "

	// 				for charIndex, char := range line {
	// 					if highestVertical[0] == charIndex {
	// 						if !columnHeadAdded {
	// 							columnHead += blue(string("v"), " ", charIndex)
	// 							columnHeadAdded = true
	// 						}
	// 						printString += fmt.Sprintf("%+s", blue(string(char)))
	// 					} else {
	// 						columnHead += " "
	// 						printString += fmt.Sprintf("%+s", string(char))
	// 					}
	// 				}
	// 				printString += "\n"
	// 			}
	// 		}
	// 		printString += "\n------------------------------\n"

	// 		fmt.Print(columnHead, "\n")
	// 		fmt.Print(printString)

	// 		spew.Dump(pattern)

	// 		fmt.Print("\n------------------------------\n")
	// 	}

	// 	sum += sumPerPattern
	// }

	return sum
}
